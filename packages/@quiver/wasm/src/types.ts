/**
 * Type definitions and helper functions for Quiver
 *
 * These types mirror the Rust types generated by tsify. They are defined inline
 * here to avoid bundling issues with the auto-generated quiver.d.ts.
 */

// =============================================================================
// Core Types (matching Rust serialization format)
// =============================================================================

/** Signal type classification */
export type SignalKind =
  | 'Audio'
  | 'CvBipolar'
  | 'CvUnipolar'
  | 'VoltPerOctave'
  | 'Gate'
  | 'Trigger'
  | 'Clock';

/** CSS hex color values for each signal type */
export interface SignalColors {
  audio: string;
  cv_bipolar: string;
  cv_unipolar: string;
  volt_per_octave: string;
  gate: string;
  trigger: string;
  clock: string;
}

/** Port definition */
export interface PortDef {
  id: number;
  name: string;
  kind: SignalKind;
  default: number;
  normalled_to?: number;
  has_attenuverter: boolean;
}

/** Enhanced port info for GUI */
export interface PortInfo {
  id: number;
  name: string;
  kind: SignalKind;
  normalled_to?: string;
  description?: string;
}

/** Port specification for a module */
export interface PortSpec {
  inputs: PortDef[];
  outputs: PortDef[];
}

/** Compatibility status for port connections */
export type Compatibility =
  | { status: 'exact' }
  | { status: 'allowed' }
  | { status: 'warning'; message: string };

/** Port summary for catalog */
export interface PortSummary {
  inputs: number;
  outputs: number;
  has_audio_in: boolean;
  has_audio_out: boolean;
}

/** Module catalog entry */
export interface ModuleCatalogEntry {
  type_id: string;
  name: string;
  category: string;
  description: string;
  keywords: string[];
  ports: PortSummary;
  tags: string[];
}

/** Catalog response */
export interface CatalogResponse {
  modules: ModuleCatalogEntry[];
  categories: string[];
}

/** Module definition for serialization */
export interface ModuleDef {
  name: string;
  module_type: string;
  position?: [number, number];
  state?: unknown;
}

/** Cable definition for serialization */
export interface CableDef {
  from: string;
  to: string;
  attenuation?: number;
  offset?: number;
}

/** Patch definition for serialization */
export interface PatchDef {
  version: number;
  name: string;
  author?: string;
  description?: string;
  tags: string[];
  modules: ModuleDef[];
  cables: CableDef[];
  parameters: Record<string, number>;
}

/** Validation error */
export interface ValidationError {
  path: string;
  message: string;
}

/** Validation result */
export interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
}

/** UI control type */
export type ControlType = 'knob' | 'slider' | 'toggle' | 'select';

/** Parameter curve */
export type ParamCurve =
  | { type: 'linear' }
  | { type: 'exponential' }
  | { type: 'logarithmic' }
  | { type: 'stepped'; steps: number };

/** Value format */
export type ValueFormat =
  | { type: 'decimal'; places: number }
  | { type: 'frequency' }
  | { type: 'time' }
  | { type: 'decibels' }
  | { type: 'percent' }
  | { type: 'note_name' }
  | { type: 'ratio' };

/** Parameter info */
export interface ParamInfo {
  id: string;
  name: string;
  value: number;
  min: number;
  max: number;
  default: number;
  curve: ParamCurve;
  control: ControlType;
  unit?: string;
  format: ValueFormat;
}

/** Observable value from state bridge */
export type ObservableValue =
  | { type: 'param'; node_id: string; param_id: string; value: number }
  | { type: 'level'; node_id: string; port_id: number; rms_db: number; peak_db: number }
  | { type: 'gate'; node_id: string; port_id: number; active: boolean }
  | { type: 'scope'; node_id: string; port_id: number; samples: number[] }
  | { type: 'spectrum'; node_id: string; port_id: number; bins: number[]; freq_range: [number, number] };

/** Subscription target */
export type SubscriptionTarget =
  | { type: 'param'; node_id: string; param_id: string }
  | { type: 'level'; node_id: string; port_id: number }
  | { type: 'gate'; node_id: string; port_id: number }
  | { type: 'scope'; node_id: string; port_id: number; buffer_size: number }
  | { type: 'spectrum'; node_id: string; port_id: number; fft_size: number };

// =============================================================================
// Type Aliases
// =============================================================================

/** Port reference string in format 'module_name.port_name' */
export type PortReference = `${string}.${string}`;

/** Module type identifier */
export type ModuleTypeId = string;

/** Module category */
export type ModuleCategory = string;

// =============================================================================
// Signal Colors
// =============================================================================

/** Default signal colors following modular synth conventions */
export const DEFAULT_SIGNAL_COLORS: SignalColors = {
  audio: '#e94560',
  cv_bipolar: '#0f3460',
  cv_unipolar: '#00b4d8',
  volt_per_octave: '#90be6d',
  gate: '#f9c74f',
  trigger: '#f8961e',
  clock: '#9d4edd',
};

/**
 * Get the color for a signal kind
 * Note: SignalKind uses PascalCase (e.g., "Audio", "CvBipolar")
 */
export function getSignalColor(
  kind: SignalKind,
  colors: SignalColors = DEFAULT_SIGNAL_COLORS
): string {
  const keyMap: Record<SignalKind, keyof SignalColors> = {
    Audio: 'audio',
    CvBipolar: 'cv_bipolar',
    CvUnipolar: 'cv_unipolar',
    VoltPerOctave: 'volt_per_octave',
    Gate: 'gate',
    Trigger: 'trigger',
    Clock: 'clock',
  };
  return colors[keyMap[kind]];
}

// =============================================================================
// Port Reference Utilities
// =============================================================================

/** Parse a port reference string into module name and port name */
export function parsePortReference(ref: PortReference): {
  moduleName: string;
  portName: string;
} {
  const parts = ref.split('.');
  if (parts.length !== 2) {
    throw new Error(`Invalid port reference: ${ref}`);
  }
  return {
    moduleName: parts[0],
    portName: parts[1],
  };
}

/** Create a port reference string from module and port names */
export function createPortReference(
  moduleName: string,
  portName: string
): PortReference {
  return `${moduleName}.${portName}` as PortReference;
}

// =============================================================================
// Observable Value Utilities
// =============================================================================

/** Get a unique key for an observable value */
export function getObservableValueKey(value: ObservableValue): string {
  switch (value.type) {
    case 'param':
      return `param:${value.node_id}:${value.param_id}`;
    case 'level':
      return `level:${value.node_id}:${value.port_id}`;
    case 'gate':
      return `gate:${value.node_id}:${value.port_id}`;
    case 'scope':
      return `scope:${value.node_id}:${value.port_id}`;
    case 'spectrum':
      return `spectrum:${value.node_id}:${value.port_id}`;
  }
}

/** Get a unique key for a subscription target */
export function getSubscriptionTargetKey(target: SubscriptionTarget): string {
  switch (target.type) {
    case 'param':
      return `param:${target.node_id}:${target.param_id}`;
    case 'level':
      return `level:${target.node_id}:${target.port_id}`;
    case 'gate':
      return `gate:${target.node_id}:${target.port_id}`;
    case 'scope':
      return `scope:${target.node_id}:${target.port_id}`;
    case 'spectrum':
      return `spectrum:${target.node_id}:${target.port_id}`;
  }
}

// =============================================================================
// Subscription Helpers
// =============================================================================

/** Create a param subscription target */
export function subscribeParam(nodeId: string, paramId: string): SubscriptionTarget {
  return { type: 'param', node_id: nodeId, param_id: paramId };
}

/** Create a level meter subscription target */
export function subscribeLevel(nodeId: string, portId: number): SubscriptionTarget {
  return { type: 'level', node_id: nodeId, port_id: portId };
}

/** Create a gate subscription target */
export function subscribeGate(nodeId: string, portId: number): SubscriptionTarget {
  return { type: 'gate', node_id: nodeId, port_id: portId };
}

/** Create a scope subscription target */
export function subscribeScope(
  nodeId: string,
  portId: number,
  bufferSize: number = 512
): SubscriptionTarget {
  return { type: 'scope', node_id: nodeId, port_id: portId, buffer_size: bufferSize };
}

/** Create a spectrum analyzer subscription target */
export function subscribeSpectrum(
  nodeId: string,
  portId: number,
  fftSize: number = 1024
): SubscriptionTarget {
  return { type: 'spectrum', node_id: nodeId, port_id: portId, fft_size: fftSize };
}

// =============================================================================
// Audio Utilities
// =============================================================================

/** Calculate RMS level in decibels from samples */
export function calculateRmsDb(samples: number[]): number {
  if (samples.length === 0) return -Infinity;
  const sumSq = samples.reduce((sum, s) => sum + s * s, 0);
  const rms = Math.sqrt(sumSq / samples.length);
  return rms > 0 ? 20 * Math.log10(rms) : -Infinity;
}

/** Calculate peak level in decibels from samples */
export function calculatePeakDb(samples: number[]): number {
  if (samples.length === 0) return -Infinity;
  const peak = samples.reduce((max, s) => Math.max(max, Math.abs(s)), 0);
  return peak > 0 ? 20 * Math.log10(peak) : -Infinity;
}

/** Format decibels for display */
export function formatDb(db: number): string {
  if (!isFinite(db)) return '-âˆž dB';
  return `${db.toFixed(1)} dB`;
}

// =============================================================================
// Patch Utilities
// =============================================================================

/** Create a new empty patch definition */
export function createPatchDef(name: string): PatchDef {
  return {
    version: 1,
    name,
    author: undefined,
    description: undefined,
    tags: [],
    modules: [],
    cables: [],
    parameters: {},
  };
}

/** Create a new module definition */
export function createModuleDef(
  name: string,
  moduleType: ModuleTypeId,
  position?: [number, number]
): ModuleDef {
  return {
    name,
    module_type: moduleType,
    position,
    state: undefined,
  };
}

/** Create a new cable definition */
export function createCableDef(
  from: PortReference,
  to: PortReference,
  options?: { attenuation?: number; offset?: number }
): CableDef {
  return {
    from,
    to,
    attenuation: options?.attenuation,
    offset: options?.offset,
  };
}

// =============================================================================
// Compatibility Checking
// =============================================================================

/** Check if two signal kinds are compatible for connection */
export function checkPortCompatibility(
  from: SignalKind,
  to: SignalKind
): Compatibility {
  if (from === to) {
    return { status: 'exact' };
  }
  if (from === 'Audio') {
    return { status: 'allowed' };
  }
  if (
    (from === 'CvBipolar' && to === 'CvUnipolar') ||
    (from === 'CvUnipolar' && to === 'CvBipolar')
  ) {
    return { status: 'allowed' };
  }
  if (from === 'VoltPerOctave' && (to === 'CvBipolar' || to === 'CvUnipolar')) {
    return { status: 'allowed' };
  }
  if ((from === 'Gate' && to === 'Trigger') || (from === 'Trigger' && to === 'Gate')) {
    return { status: 'allowed' };
  }
  if ((from === 'Clock' && to === 'Gate') || (from === 'Clock' && to === 'Trigger')) {
    return { status: 'allowed' };
  }
  if ((from === 'Gate' || from === 'Trigger') && to === 'Audio') {
    return { status: 'warning', message: 'Gate/Trigger to Audio may cause clicks' };
  }
  if (from === 'CvBipolar' && to === 'VoltPerOctave') {
    return { status: 'warning', message: 'CV to V/Oct may cause tuning issues' };
  }
  return { status: 'allowed' };
}

// =============================================================================
// Value Formatting
// =============================================================================

/** Format a value according to a ValueFormat specification */
export function formatParamValue(value: number, format: ValueFormat): string {
  switch (format.type) {
    case 'decimal':
      return value.toFixed(format.places);
    case 'frequency':
      return value >= 1000 ? `${(value / 1000).toFixed(2)} kHz` : `${value.toFixed(1)} Hz`;
    case 'time':
      return value >= 1 ? `${value.toFixed(2)} s` : `${(value * 1000).toFixed(1)} ms`;
    case 'decibels':
      return `${value.toFixed(1)} dB`;
    case 'percent':
      return `${(value * 100).toFixed(0)}%`;
    case 'note_name': {
      const midiNote = Math.round(value * 12 + 60);
      const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      const note = noteNames[((midiNote % 12) + 12) % 12];
      const octave = Math.floor(midiNote / 12) - 1;
      return `${note}${octave}`;
    }
    case 'ratio':
      return value >= 1 ? `${value.toFixed(1)}:1` : value > 0 ? `1:${(1 / value).toFixed(1)}` : '0:1';
  }
}

/** Apply a parameter curve to convert normalized (0-1) to actual value */
export function applyParamCurve(
  normalized: number,
  min: number,
  max: number,
  curve: ParamCurve
): number {
  const n = Math.max(0, Math.min(1, normalized));
  switch (curve.type) {
    case 'linear':
      return min + n * (max - min);
    case 'exponential':
      return min <= 0 ? n * max : min * Math.pow(max / min, n);
    case 'logarithmic': {
      const logMin = min > 0 ? Math.log10(min) : 0;
      const logMax = Math.log10(Math.max(max, 0.001));
      return Math.pow(10, logMin + n * (logMax - logMin));
    }
    case 'stepped': {
      const stepSize = (max - min) / curve.steps;
      const stepIndex = Math.min(Math.floor(n * curve.steps), curve.steps - 1);
      return min + stepIndex * stepSize;
    }
  }
}

/** Normalize an actual value to 0-1 based on a parameter curve */
export function normalizeParamValue(
  value: number,
  min: number,
  max: number,
  curve: ParamCurve
): number {
  if (Math.abs(max - min) < 1e-10) return 0;
  switch (curve.type) {
    case 'linear':
      return Math.max(0, Math.min(1, (value - min) / (max - min)));
    case 'exponential':
      if (min <= 0 || value <= 0) {
        return Math.max(0, Math.min(1, (value - min) / (max - min)));
      }
      return Math.max(0, Math.min(1, Math.log(value / min) / Math.log(max / min)));
    case 'logarithmic': {
      const logMin = min > 0 ? Math.log10(min) : 0;
      const logMax = Math.log10(Math.max(max, 0.001));
      const logVal = Math.log10(Math.max(value, 0.001));
      return Math.max(0, Math.min(1, (logVal - logMin) / (logMax - logMin)));
    }
    case 'stepped': {
      const stepSize = (max - min) / curve.steps;
      const stepIndex = Math.round((value - min) / stepSize);
      return Math.max(0, Math.min(1, stepIndex / curve.steps));
    }
  }
}

// =============================================================================
// Search Utilities
// =============================================================================

/** Search modules by query string (client-side) */
export function searchModules(
  modules: ModuleCatalogEntry[],
  query: string
): ModuleCatalogEntry[] {
  const q = query.toLowerCase();
  const scored = modules
    .map((m) => {
      let score = 0;
      if (m.type_id.toLowerCase() === q) score = 100;
      else if (m.name.toLowerCase() === q) score = 90;
      else if (m.type_id.toLowerCase().includes(q)) score = 70;
      else if (m.name.toLowerCase().includes(q)) score = 60;
      else if (m.keywords.some((k) => k.toLowerCase() === q)) score = 50;
      else if (m.keywords.some((k) => k.toLowerCase().includes(q))) score = 40;
      else if (m.description.toLowerCase().includes(q)) score = 20;
      else if (m.category.toLowerCase().includes(q)) score = 10;
      return { module: m, score };
    })
    .filter((item) => item.score > 0)
    .sort((a, b) => b.score - a.score || a.module.name.localeCompare(b.module.name));
  return scored.map((item) => item.module);
}

/** Filter modules by category */
export function filterByCategory(
  modules: ModuleCatalogEntry[],
  category: string
): ModuleCatalogEntry[] {
  return modules.filter((m) => m.category === category).sort((a, b) => a.name.localeCompare(b.name));
}

/** Filter modules by tag */
export function filterByTag(modules: ModuleCatalogEntry[], tag: string): ModuleCatalogEntry[] {
  return modules.filter((m) => m.tags.includes(tag));
}

/** Get all unique categories from modules */
export function getCategories(modules: ModuleCatalogEntry[]): string[] {
  const categories = new Set<string>();
  for (const m of modules) {
    categories.add(m.category);
  }
  return Array.from(categories).sort();
}
