/**
 * @quiver/wasm - WASM bindings for Quiver modular synthesizer
 *
 * This package provides the core WASM engine for running Quiver
 * in a browser environment.
 */

// Re-export the WASM bindings
// Note: These will be generated by wasm-pack build
export type { QuiverEngine, QuiverError } from '../quiver';

// Re-export AudioWorklet utilities (legacy API - uses message passing)
export {
  createQuiverAudioNode,
  createQuiverAudio,
  type QuiverAudioNode,
  type QuiverAudioNodeOptions,
} from './audio';

// Re-export new AudioManager API (recommended - uses SharedArrayBuffer)
export {
  AudioManager,
  createAudioManager,
  type AudioManagerOptions,
  type UnderrunCallback,
} from './audio-manager';

// Initialize the WASM module
let wasmInitPromise: Promise<void> | null = null;

/**
 * Initialize the WASM module
 *
 * This must be called before creating a QuiverEngine instance.
 * It's safe to call multiple times - subsequent calls will return
 * the same promise.
 *
 * @example
 * ```typescript
 * import { initWasm, QuiverEngine } from '@quiver/wasm';
 *
 * await initWasm();
 * const engine = new QuiverEngine(44100);
 * ```
 */
export async function initWasm(): Promise<void> {
  if (!wasmInitPromise) {
    wasmInitPromise = import('../quiver').then(async (wasm) => {
      // The default export is the init function
      await (wasm as any).default();
    });
  }
  return wasmInitPromise;
}

/**
 * Create a new QuiverEngine instance
 *
 * This is a convenience function that ensures WASM is initialized
 * before creating the engine.
 *
 * @param sampleRate The audio sample rate (e.g., 44100, 48000)
 * @returns A new QuiverEngine instance
 */
export async function createEngine(sampleRate: number): Promise<any> {
  await initWasm();
  const { QuiverEngine } = await import('../quiver');
  return new QuiverEngine(sampleRate);
}

/**
 * Audio context helper for setting up Quiver audio in the browser
 */
export interface QuiverAudioContext {
  audioContext: AudioContext;
  workletNode: AudioWorkletNode;
  engine: any;
  connect: (destination: AudioNode) => void;
  disconnect: () => void;
  loadPatch: (patch: any) => Promise<void>;
  setParam: (nodeId: string, paramIndex: number, value: number) => void;
  close: () => Promise<void>;
}

/**
 * Create a full audio context with Quiver engine
 *
 * This sets up an AudioWorklet for real-time audio processing.
 *
 * @param workletUrl URL to the AudioWorklet processor script
 * @returns A QuiverAudioContext with connected audio nodes
 */
export async function createAudioContext(
  workletUrl: string
): Promise<QuiverAudioContext> {
  await initWasm();

  const audioContext = new AudioContext();
  const { QuiverEngine } = await import('../quiver');

  // Create engine in main thread for now
  // Full worklet implementation requires SharedArrayBuffer
  const engine = new QuiverEngine(audioContext.sampleRate);

  // Load the worklet module
  await audioContext.audioWorklet.addModule(workletUrl);

  // Create worklet node
  const workletNode = new AudioWorkletNode(audioContext, 'quiver-processor', {
    numberOfInputs: 0,
    numberOfOutputs: 1,
    outputChannelCount: [2],
  });

  // Send engine reference to worklet (simplified - real impl needs SharedArrayBuffer)
  workletNode.port.postMessage({ type: 'init', sampleRate: audioContext.sampleRate });

  return {
    audioContext,
    workletNode,
    engine,
    connect: (destination: AudioNode) => {
      workletNode.connect(destination);
    },
    disconnect: () => {
      workletNode.disconnect();
    },
    loadPatch: async (patch: any) => {
      engine.load_patch(patch);
      engine.compile();
    },
    setParam: (nodeId: string, paramIndex: number, value: number) => {
      engine.set_param(nodeId, paramIndex, value);
    },
    close: async () => {
      workletNode.disconnect();
      await audioContext.close();
    },
  };
}
